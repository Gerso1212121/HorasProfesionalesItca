import 'dart:developer' as developer;
import '../Data/Models/sesion_chat.dart';
import '../Data/Models/analisis_sesion.dart';

class AnalisisEmocional {
  // Diccionarios de palabras clave por emoci칩n
  static const Map<String, List<String>> _palabrasEmociones = {
    'ansiedad': [
      'ansioso',
      'nervioso',
      'preocupado',
      'estresado',
      'agobiado',
      'inquieto',
      'tenso',
      'angustiado',
      'intranquilo',
      'agitado',
      'p치nico',
      'miedo',
      'temor',
      'terror',
      'fobia'
    ],
    'depresi칩n': [
      'triste',
      'deprimido',
      'melanc칩lico',
      'desanimado',
      'abatido',
      'desesperanzado',
      'vac칤o',
      'solo',
      'aislado',
      'desesperado',
      'in칰til',
      'culpable',
      'pesimista',
      'desalentado'
    ],
    'ira': [
      'enojado',
      'furioso',
      'molesto',
      'irritado',
      'frustrado',
      'rabioso',
      'indignado',
      'enfadado',
      'col칠rico',
      'hostil'
    ],
    'alegr칤a': [
      'feliz',
      'contento',
      'alegre',
      'euf칩rico',
      'optimista',
      'esperanzado',
      'motivado',
      'entusiasmado',
      'satisfecho',
      'pleno'
    ],
    'miedo': [
      'asustado',
      'aterrorizado',
      'temeroso',
      'espantado',
      'horrorizado',
      'intimidado',
      'cobarde',
      't칤mido',
      'inseguro'
    ],
    'confusi칩n': [
      'confundido',
      'perdido',
      'desorientado',
      'dudoso',
      'incierto',
      'indeciso',
      'perplejo',
      'desconcertado'
    ]
  };

  // Palabras que indican riesgo
  static const List<String> _palabrasRiesgo = [
    'suicidio',
    'matarme',
    'acabar',
    'terminar',
    'morir',
    'lastimar',
    'da침ar',
    'cortar',
    'herir',
    'dolor',
    'no puedo m치s',
    'sin salida',
    'sin esperanza',
    'in칰til',
    'mejor muerto',
    'desaparecer',
    'no sirvo'
  ];

  // Temas generales
  static const Map<String, List<String>> _temas = {
    'acad칠mico': [
      'estudios',
      'universidad',
      'examen',
      'tarea',
      'calificaci칩n',
      'profesor',
      'clase',
      'carrera',
      'semestre',
      'graduaci칩n'
    ],
    'familiar': [
      'familia',
      'padres',
      'hermanos',
      'casa',
      'hogar',
      'mam치',
      'pap치',
      'conflicto familiar',
      'divorcio'
    ],
    'relaciones': [
      'pareja',
      'novio',
      'novia',
      'amor',
      'relaci칩n',
      'amistad',
      'amigos',
      'social',
      'citas'
    ],
    'laboral': [
      'trabajo',
      'empleo',
      'jefe',
      'compa침eros',
      'oficina',
      'sueldo',
      'carrera profesional',
      'entrevista'
    ],
    'salud': [
      'enfermedad',
      'dolor',
      'm칠dico',
      'hospital',
      's칤ntomas',
      'medicamento',
      'tratamiento',
      'salud mental'
    ],
    'personal': [
      'autoestima',
      'identidad',
      'personalidad',
      'crecimiento',
      'metas',
      'sue침os',
      'futuro',
      'prop칩sito'
    ]
  };

  static Future<AnalisisSesion> analizarSesion(SesionChat sesion) async {
    developer.log('游댌 Iniciando an치lisis de sesi칩n...');

    // Concatenar todo el contenido de los mensajes del usuario
    final contenidoCompleto = sesion.mensajes
        .where((m) => m.emisor == "Usuario")
        .map((m) => m.contenido.toLowerCase())
        .join(" ");

    developer.log(
        '游닇 Contenido a analizar: ${contenidoCompleto.length > 100 ? contenidoCompleto.substring(0, 100) + "..." : contenidoCompleto}');

    // Validar que hay contenido para analizar
    if (contenidoCompleto.trim().isEmpty) {
      developer.log('丘멆잺 No hay contenido del usuario para analizar');
      return AnalisisSesion(
        fechaSesion: sesion.fecha,
        temaGeneral: 'general',
        emociones: {'neutral': 100.0},
        nivelRiesgo: 'bajo',
        puntuacionRiesgo: 0.0,
        palabrasClave: [],
        resumenAnalisis: 'Sesi칩n sin contenido del usuario para analizar',
        idSesionChat: sesion.fecha.hashCode,
      );
    }

    // Analizar emociones
    final emociones = _analizarEmociones(contenidoCompleto);
    developer.log('游땕 Emociones detectadas: $emociones');

    // Detectar tema general
    final tema = _detectarTema(contenidoCompleto);
    developer.log('游꿢 Tema detectado: $tema');

    // Calcular riesgo
    final riesgo = _calcularRiesgo(contenidoCompleto);
    developer.log(
        '丘멆잺 Nivel de riesgo: ${riesgo['nivel']} (${riesgo['puntuacion']})');

    // Extraer palabras clave
    final palabrasClave = _extraerPalabrasClave(contenidoCompleto);
    developer.log('游댐 Palabras clave: $palabrasClave');

    // Generar resumen
    final resumen = _generarResumen(emociones, tema, riesgo['nivel']);

    return AnalisisSesion(
      fechaSesion: sesion.fecha,
      temaGeneral: tema,
      emociones: emociones,
      nivelRiesgo: riesgo['nivel'],
      puntuacionRiesgo: riesgo['puntuacion'],
      palabrasClave: palabrasClave,
      resumenAnalisis: resumen,
      idSesionChat: sesion.fecha.hashCode,
    );
  }

  static Map<String, double> _analizarEmociones(String contenido) {
    Map<String, double> conteoEmociones = {};
    int totalPalabras = 0;

    _palabrasEmociones.forEach((emocion, palabras) {
      int conteo = 0;
      for (String palabra in palabras) {
        conteo += _contarOcurrencias(contenido, palabra);
      }
      conteoEmociones[emocion] = conteo.toDouble();
      totalPalabras += conteo;
    });

    // Convertir a porcentajes
    if (totalPalabras > 0) {
      conteoEmociones.forEach((emocion, conteo) {
        double porcentaje = (conteo / totalPalabras) * 100;
        conteoEmociones[emocion] = porcentaje.clamp(0.0, 100.0);
      });
    } else {
      // Si no se detectan emociones espec칤ficas, asignar neutral
      conteoEmociones.clear();
      conteoEmociones['neutral'] = 100.0;
    }

    return conteoEmociones;
  }

  static String _detectarTema(String contenido) {
    Map<String, int> puntuacionTemas = {};

    _temas.forEach((tema, palabras) {
      int puntuacion = 0;
      for (String palabra in palabras) {
        puntuacion += _contarOcurrencias(contenido, palabra);
      }
      puntuacionTemas[tema] = puntuacion;
    });

    // Encontrar el tema con mayor puntuaci칩n
    String temaPrincipal = 'general';
    int maxPuntuacion = 0;

    puntuacionTemas.forEach((tema, puntuacion) {
      if (puntuacion > maxPuntuacion) {
        maxPuntuacion = puntuacion;
        temaPrincipal = tema;
      }
    });

    return maxPuntuacion > 0 ? temaPrincipal : 'general';
  }

  static Map<String, dynamic> _calcularRiesgo(String contenido) {
    int puntuacionRiesgo = 0;

    // Buscar palabras de riesgo
    for (String palabra in _palabrasRiesgo) {
      puntuacionRiesgo += _contarOcurrencias(contenido, palabra) * 10;
    }

    // Buscar patrones de riesgo adicionales
    if (contenido.contains('no puedo') && contenido.contains('m치s')) {
      puntuacionRiesgo += 15;
    }
    if (contenido.contains('sin esperanza') ||
        contenido.contains('sin salida')) {
      puntuacionRiesgo += 20;
    }

    // Limitar la puntuaci칩n a un m치ximo de 100
    puntuacionRiesgo = puntuacionRiesgo.clamp(0, 100);

    // Determinar nivel de riesgo
    String nivel;
    if (puntuacionRiesgo >= 50) {
      nivel = 'cr칤tico';
    } else if (puntuacionRiesgo >= 30) {
      nivel = 'alto';
    } else if (puntuacionRiesgo >= 15) {
      nivel = 'medio';
    } else {
      nivel = 'bajo';
    }

    return {
      'nivel': nivel,
      'puntuacion': puntuacionRiesgo.toDouble(),
    };
  }

  static List<String> _extraerPalabrasClave(String contenido) {
    List<String> palabrasClave = [];

    // Buscar todas las palabras emocionales encontradas
    _palabrasEmociones.forEach((emocion, palabras) {
      for (String palabra in palabras) {
        if (contenido.contains(palabra) && !palabrasClave.contains(palabra)) {
          palabrasClave.add(palabra);
        }
      }
    });

    // Buscar palabras de riesgo
    for (String palabra in _palabrasRiesgo) {
      if (contenido.contains(palabra) && !palabrasClave.contains(palabra)) {
        palabrasClave.add(palabra);
      }
    }

    return palabrasClave.take(10).toList(); // Limitar a 10 palabras clave
  }

  static String _generarResumen(
      Map<String, double> emociones, String tema, String nivelRiesgo) {
    String emocionPrincipal = 'neutral';
    double maxPorcentaje = 0;

    emociones.forEach((emocion, porcentaje) {
      if (porcentaje > maxPorcentaje) {
        maxPorcentaje = porcentaje;
        emocionPrincipal = emocion;
      }
    });

    String resumen = 'Sesi칩n sobre $tema. ';

    if (maxPorcentaje > 0) {
      resumen +=
          'Emoci칩n predominante: $emocionPrincipal (${maxPorcentaje.toStringAsFixed(1)}%). ';
    }

    if (nivelRiesgo != 'bajo') {
      resumen += 'Nivel de riesgo: $nivelRiesgo. ';
    }

    return resumen;
  }

  static int _contarOcurrencias(String texto, String palabra) {
    return palabra.allMatches(texto).length;
  }
}
